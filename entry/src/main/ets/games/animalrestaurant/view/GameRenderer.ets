import { Customer } from '../model/Customer';
import { Table } from '../model/Table';
import { Dish } from '../model/Dish';
import { Restaurant } from '../model/Restaurant';
import { GameConstants, GameState, CustomerState, TableState, DishState } from '../model/GameConstants';

/**
 * æ¸¸æˆæ¸²æŸ“å™¨ - è´Ÿè´£ç»˜åˆ¶åŠ¨ç‰©é¤å…çš„æ‰€æœ‰å…ƒç´ 
 */
export class GameRenderer {
  private canvasWidth: number = GameConstants.CANVAS_WIDTH;
  private canvasHeight: number = GameConstants.CANVAS_HEIGHT;

  /**
   * ä¸»æ¸²æŸ“æ–¹æ³•
   */
  render(
    canvas: CanvasRenderingContext2D,
    tables: Table[],
    waitingCustomers: Customer[],
    allCustomers: Customer[],
    dishes: Dish[],
    restaurant: Restaurant,
    gameState: GameState
  ): void {
    this.clearCanvas(canvas);
    this.drawBackground(canvas);
    this.drawKitchen(canvas);
    this.drawWaitingArea(canvas, waitingCustomers);
    this.drawTables(canvas, tables);
    this.drawCustomers(canvas, allCustomers);
    this.drawDishes(canvas, dishes);
    this.drawHUD(canvas, restaurant);

    if (gameState === GameState.IDLE) {
      this.drawStartPrompt(canvas);
    } else if (gameState === GameState.PAUSED) {
      this.drawPaused(canvas);
    }
  }

  /**
   * æ¸…ç©ºç”»å¸ƒ
   */
  private clearCanvas(canvas: CanvasRenderingContext2D): void {
    canvas.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
  }

  /**
   * ç»˜åˆ¶èƒŒæ™¯
   */
  private drawBackground(canvas: CanvasRenderingContext2D): void {
    // æ¸©é¦¨çš„ç±³è‰²èƒŒæ™¯
    canvas.fillStyle = GameConstants.COLOR_BACKGROUND;
    canvas.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    // åœ°æ¿
    canvas.fillStyle = '#DEB887';
    canvas.fillRect(0, GameConstants.TABLE_START_Y - 20, this.canvasWidth, this.canvasHeight);

    // åœ°æ¿çº¹ç†
    canvas.strokeStyle = '#C4A777';
    canvas.lineWidth = 1;
    for (let i = 0; i < this.canvasWidth; i += 40) {
      canvas.beginPath();
      canvas.moveTo(i, GameConstants.TABLE_START_Y - 20);
      canvas.lineTo(i, this.canvasHeight);
      canvas.stroke();
    }
  }

  /**
   * ç»˜åˆ¶å¨æˆ¿åŒºåŸŸ
   */
  private drawKitchen(canvas: CanvasRenderingContext2D): void {
    // å¨æˆ¿èƒŒæ™¯
    canvas.fillStyle = GameConstants.COLOR_KITCHEN;
    canvas.fillRect(
      GameConstants.KITCHEN_X,
      GameConstants.KITCHEN_Y,
      GameConstants.KITCHEN_WIDTH,
      GameConstants.KITCHEN_HEIGHT
    );

    // å¨æˆ¿è¾¹æ¡†
    canvas.strokeStyle = '#333333';
    canvas.lineWidth = 2;
    canvas.strokeRect(
      GameConstants.KITCHEN_X,
      GameConstants.KITCHEN_Y,
      GameConstants.KITCHEN_WIDTH,
      GameConstants.KITCHEN_HEIGHT
    );

    // å¨æˆ¿æ ‡ç­¾
    canvas.fillStyle = '#FFFFFF';
    canvas.font = 'bold 20px sans-serif';
    canvas.textAlign = 'center';
    canvas.fillText('å¨æˆ¿', GameConstants.KITCHEN_X + GameConstants.KITCHEN_WIDTH / 2, GameConstants.KITCHEN_Y + 28);

    // å¨å¸ˆå›¾æ ‡
    canvas.font = '36px sans-serif';
    canvas.fillText('ğŸ‘¨â€ğŸ³', GameConstants.KITCHEN_X + GameConstants.KITCHEN_WIDTH / 2, GameConstants.KITCHEN_Y + 62);
  }

  /**
   * ç»˜åˆ¶ç­‰å¾…åŒº
   */
  private drawWaitingArea(canvas: CanvasRenderingContext2D, customers: Customer[]): void {
    // ç­‰å¾…åŒºèƒŒæ™¯
    canvas.fillStyle = '#E8E8E8';
    canvas.fillRect(GameConstants.KITCHEN_X + GameConstants.KITCHEN_WIDTH + 10, GameConstants.KITCHEN_Y, 180, GameConstants.KITCHEN_HEIGHT);

    // ç­‰å¾…åŒºè¾¹æ¡†
    canvas.strokeStyle = '#CCCCCC';
    canvas.lineWidth = 1;
    canvas.strokeRect(GameConstants.KITCHEN_X + GameConstants.KITCHEN_WIDTH + 10, GameConstants.KITCHEN_Y, 180, GameConstants.KITCHEN_HEIGHT);

    // ç­‰å¾…åŒºæ ‡ç­¾
    canvas.fillStyle = '#666666';
    canvas.font = '18px sans-serif';
    canvas.textAlign = 'center';
    canvas.fillText('ç­‰å¾…åŒº', GameConstants.KITCHEN_X + GameConstants.KITCHEN_WIDTH + 100, GameConstants.KITCHEN_Y + 20);
  }

  /**
   * ç»˜åˆ¶é¤æ¡Œ
   */
  private drawTables(canvas: CanvasRenderingContext2D, tables: Table[]): void {
    for (const table of tables) {
      // æ¡Œå­é˜´å½±
      canvas.fillStyle = 'rgba(0, 0, 0, 0.1)';
      canvas.fillRect(table.x + 3, table.y + 3, table.width, table.height);

      // æ¡Œå­æœ¬ä½“
      canvas.fillStyle = GameConstants.COLOR_TABLE;
      canvas.fillRect(table.x, table.y, table.width, table.height);

      // æ¡Œå¸ƒ
      canvas.fillStyle = GameConstants.COLOR_TABLECLOTH;
      canvas.fillRect(table.x + 5, table.y + 5, table.width - 10, table.height - 10);

      // æ ¹æ®çŠ¶æ€ç»˜åˆ¶æŒ‡ç¤º
      if (table.state === TableState.NEEDS_CLEAN) {
        // éœ€è¦æ¸…ç† - æ˜¾ç¤ºè„ç›˜å­
        canvas.fillStyle = '#FF6B6B';
        canvas.font = '16px sans-serif';
        canvas.textAlign = 'center';
        canvas.fillText('ğŸ½ï¸', table.x + table.width / 2, table.y + table.height / 2 + 5);
        canvas.font = '10px sans-serif';
        canvas.fillText('ç‚¹å‡»æ¸…ç†', table.x + table.width / 2, table.y + table.height + 12);
      } else if (table.state === TableState.OCCUPIED && table.customer) {
        // æœ‰é¡¾å®¢ - æ˜¾ç¤ºç‚¹é¤æ°”æ³¡
        if (table.customer.state === CustomerState.ORDERING) {
          canvas.fillStyle = '#4CAF50';
          canvas.font = '12px sans-serif';
          canvas.fillText('ğŸ’­', table.x + table.width / 2, table.y - 5);
        } else if (table.customer.state === CustomerState.WAITING_FOOD) {
          canvas.fillStyle = '#FF9800';
          canvas.font = '12px sans-serif';
          canvas.fillText('â³', table.x + table.width / 2, table.y - 5);
        }
      }

      // æ¡Œå­è¾¹æ¡†
      canvas.strokeStyle = '#5D4037';
      canvas.lineWidth = 2;
      canvas.strokeRect(table.x, table.y, table.width, table.height);
    }
  }

  /**
   * ç»˜åˆ¶é¡¾å®¢
   */
  private drawCustomers(canvas: CanvasRenderingContext2D, customers: Customer[]): void {
    for (const customer of customers) {
      const rect = customer.getCollisionRect();

      // é¡¾å®¢èƒŒæ™¯åœ†
      canvas.beginPath();
      canvas.arc(customer.x, customer.y, customer.size / 2, 0, Math.PI * 2);
      canvas.fillStyle = customer.color;
      canvas.fill();
      canvas.strokeStyle = '#333333';
      canvas.lineWidth = 2;
      canvas.stroke();

      // åŠ¨ç‰©emoji
      canvas.font = `${customer.size * 0.8}px sans-serif`;
      canvas.textAlign = 'center';
      canvas.textBaseline = 'middle';
      canvas.fillText(customer.emoji, customer.x, customer.y);

      // è€å¿ƒæ¡ï¼ˆä»…åœ¨ç­‰å¾…æˆ–ç­‰å¾…é£Ÿç‰©æ—¶æ˜¾ç¤ºï¼‰
      if (customer.state === CustomerState.WAITING ||
          customer.state === CustomerState.WAITING_FOOD) {
        this.drawPatienceBar(canvas, customer);
      }

      // çŠ¶æ€æŒ‡ç¤º
      if (customer.state === CustomerState.EATING) {
        canvas.font = '12px sans-serif';
        canvas.fillText('ğŸ˜‹', customer.x, customer.y - customer.size / 2 - 10);
      } else if (customer.state === CustomerState.ORDERING) {
        canvas.font = '12px sans-serif';
        canvas.fillText('ğŸ“‹', customer.x, customer.y - customer.size / 2 - 10);
      }
    }
  }

  /**
   * ç»˜åˆ¶è€å¿ƒæ¡
   */
  private drawPatienceBar(canvas: CanvasRenderingContext2D, customer: Customer): void {
    const barWidth = 40;
    const barHeight = 6;
    const barX = customer.x - barWidth / 2;
    const barY = customer.y + customer.size / 2 + 5;

    // èƒŒæ™¯æ¡
    canvas.fillStyle = '#CCCCCC';
    canvas.fillRect(barX, barY, barWidth, barHeight);

    // è€å¿ƒè¿›åº¦
    const patiencePercent = customer.getPatiencePercent();
    let color = GameConstants.COLOR_HAPPY;
    if (patiencePercent < 0.3) {
      color = GameConstants.COLOR_DANGER;
    } else if (patiencePercent < 0.6) {
      color = GameConstants.COLOR_WARNING;
    }

    canvas.fillStyle = color;
    canvas.fillRect(barX, barY, barWidth * patiencePercent, barHeight);

    // è¾¹æ¡†
    canvas.strokeStyle = '#333333';
    canvas.lineWidth = 1;
    canvas.strokeRect(barX, barY, barWidth, barHeight);
  }

  /**
   * ç»˜åˆ¶èœå“
   */
  private drawDishes(canvas: CanvasRenderingContext2D, dishes: Dish[]): void {
    for (const dish of dishes) {
      // èœå“èƒŒæ™¯
      canvas.beginPath();
      canvas.arc(dish.x, dish.y, dish.size / 2, 0, Math.PI * 2);
      canvas.fillStyle = '#FFFFFF';
      canvas.fill();
      canvas.strokeStyle = dish.color;
      canvas.lineWidth = 2;
      canvas.stroke();

      // èœå“emoji
      canvas.font = `${dish.size * 0.5}px sans-serif`;
      canvas.textAlign = 'center';
      canvas.textBaseline = 'middle';
      canvas.fillText(dish.emoji, dish.x, dish.y);

      // çƒ¹é¥ªè¿›åº¦æ¡
      if (dish.state === DishState.COOKING) {
        const barWidth = 30;
        const barHeight = 4;
        const barX = dish.x - barWidth / 2;
        const barY = dish.y + dish.size / 2 + 3;

        canvas.fillStyle = '#CCCCCC';
        canvas.fillRect(barX, barY, barWidth, barHeight);
        canvas.fillStyle = '#4CAF50';
        canvas.fillRect(barX, barY, barWidth * dish.cookingProgress, barHeight);
      }

      // å‡†å¤‡å¥½æç¤º
      if (dish.state === DishState.READY) {
        canvas.fillStyle = '#4CAF50';
        canvas.font = '10px sans-serif';
        canvas.fillText('âœ“ ç‚¹å‡»ä¸Šèœ', dish.x, dish.y + dish.size / 2 + 12);
      }
    }
  }

  /**
   * ç»˜åˆ¶HUDï¼ˆå¤´éƒ¨ä¿¡æ¯ï¼‰
   */
  private drawHUD(canvas: CanvasRenderingContext2D, restaurant: Restaurant): void {
    // é‡‘å¸
    canvas.fillStyle = GameConstants.COLOR_GOLD;
    canvas.font = 'bold 24px sans-serif';
    canvas.textAlign = 'left';
    canvas.textBaseline = 'top';
    canvas.fillText(`ğŸ’° ${restaurant.coins}`, 170, GameConstants.KITCHEN_Y + 18);

    // ç­‰çº§
    canvas.fillStyle = '#4CAF50';
    canvas.fillText(`â­ Lv.${restaurant.level}`, 170, GameConstants.KITCHEN_Y + 48);

    // æ»¡æ„åº¦
    canvas.fillStyle = '#FF6B6B';
    canvas.fillText(`â¤ï¸ ${restaurant.getSatisfactionRate()}%`, 170, GameConstants.KITCHEN_Y + 78);
  }

  /**
   * ç»˜åˆ¶å¼€å§‹æç¤º
   */
  private drawStartPrompt(canvas: CanvasRenderingContext2D): void {
    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';
    canvas.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    canvas.fillStyle = '#FFFFFF';
    canvas.font = 'bold 32px sans-serif';
    canvas.textAlign = 'center';
    canvas.textBaseline = 'middle';
    canvas.fillText('ğŸ¾ åŠ¨ç‰©é¤å… ğŸ¾', this.canvasWidth / 2, this.canvasHeight / 2 - 60);

    canvas.font = '18px sans-serif';
    canvas.fillText('æ¬¢è¿æ¥åˆ°æ¸©é¦¨çš„åŠ¨ç‰©é¤å…ï¼', this.canvasWidth / 2, this.canvasHeight / 2 - 20);

    canvas.font = '16px sans-serif';
    canvas.fillText('æ‹›å¾…å¯çˆ±çš„åŠ¨ç‰©é¡¾å®¢', this.canvasWidth / 2, this.canvasHeight / 2 + 20);
    canvas.fillText('çƒ¹é¥ªç¾å‘³çš„èœè‚´', this.canvasWidth / 2, this.canvasHeight / 2 + 45);

    canvas.font = 'bold 20px sans-serif';
    canvas.fillStyle = '#4CAF50';
    canvas.fillText('ç‚¹å‡»å¼€å§‹è¥ä¸š', this.canvasWidth / 2, this.canvasHeight / 2 + 90);
  }

  /**
   * ç»˜åˆ¶æš‚åœç•Œé¢
   */
  private drawPaused(canvas: CanvasRenderingContext2D): void {
    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';
    canvas.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    canvas.fillStyle = '#FFFFFF';
    canvas.font = 'bold 32px sans-serif';
    canvas.textAlign = 'center';
    canvas.textBaseline = 'middle';
    canvas.fillText('â¸ï¸ æ¸¸æˆæš‚åœ', this.canvasWidth / 2, this.canvasHeight / 2 - 20);

    canvas.font = '18px sans-serif';
    canvas.fillText('ç‚¹å‡»ç»§ç»­', this.canvasWidth / 2, this.canvasHeight / 2 + 30);
  }
}
