import { Player } from '../../../model/Player';
import { Creature } from '../../../model/Creature';
import { GameState } from '../../../model/GameState';
import { GameConstants } from '../../../common/constants/GameConstants';
import { Camera, Point } from '../viewmodel/GameEngine';
import { ImageManager } from '../../../common/utils/ImageManager';

/**
 * æ¸¸æˆæ¸²æŸ“å™¨ - å¬å”¤ç¥é¾™
 */
export class GameRenderer {
  private canvasWidth: number = GameConstants.CANVAS_WIDTH;
  private canvasHeight: number = GameConstants.CANVAS_HEIGHT;

  render(
    canvas: CanvasRenderingContext2D,
    player: Player,
    creatures: Creature[],
    score: number,
    gameState: GameState,
    hasWon: boolean,
    playTime: number,
    camera: Camera
  ): void {
    this.clearCanvas(canvas);
    this.drawBackground(canvas);

    if (gameState === GameState.PLAYING || gameState === GameState.GAME_OVER) {
      this.drawCreatures(canvas, creatures, camera, player);
      this.drawPlayer(canvas, player, camera);
      this.drawBoundaryWarning(canvas, player, camera);
      this.drawMinimap(canvas, player, creatures, camera);
      this.drawHUD(canvas, player, score, playTime);
    }

    if (gameState === GameState.IDLE) {
      this.drawStartPrompt(canvas);
    } else if (gameState === GameState.GAME_OVER) {
      this.drawGameOver(canvas, score, hasWon);
    }
  }

  private clearCanvas(canvas: CanvasRenderingContext2D): void {
    canvas.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
  }

  private drawBackground(canvas: CanvasRenderingContext2D): void {
    // æ·±æµ·æ¸å˜èƒŒæ™¯
    const gradient = canvas.createLinearGradient(0, 0, 0, this.canvasHeight);
    gradient.addColorStop(0, '#0a1628');
    gradient.addColorStop(0.5, '#1a4a7a');
    gradient.addColorStop(1, '#0d2847');
    canvas.fillStyle = gradient;
    canvas.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    // ç»˜åˆ¶æ°´æ³¢çº¹æ•ˆæœ
    canvas.strokeStyle = 'rgba(255, 255, 255, 0.03)';
    canvas.lineWidth = 1;
    for (let i = 0; i < 10; i++) {
      canvas.beginPath();
      canvas.arc(this.canvasWidth / 2, this.canvasHeight / 2, 50 + i * 40, 0, Math.PI * 2);
      canvas.stroke();
    }
  }

  private drawPlayer(canvas: CanvasRenderingContext2D, player: Player, camera: Camera): void {
    const screenPos: Point = camera.worldToScreen(player.x, player.y);
    const radius = player.getRadius();
    const imageManager = ImageManager.getInstance();
    const imageKey = imageManager.getPlayerImageKey(player.evolutionLevel);
    const cachedImage = imageManager.getCachedImage(imageKey);

    // ç©å®¶å…‰æ™•
    const glowGradient = canvas.createRadialGradient(
      screenPos.x, screenPos.y, 0,
      screenPos.x, screenPos.y, radius * 1.5
    );
    glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
    glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
    canvas.fillStyle = glowGradient;
    canvas.beginPath();
    canvas.arc(screenPos.x, screenPos.y, radius * 1.5, 0, Math.PI * 2);
    canvas.fill();

    if (cachedImage) {
      // ä½¿ç”¨å›¾ç‰‡ç»˜åˆ¶
      canvas.drawImage(
        cachedImage,
        screenPos.x - radius,
        screenPos.y - radius,
        radius * 2,
        radius * 2
      );
    } else {
      // å›é€€åˆ°åœ†å½¢ç»˜åˆ¶
      canvas.fillStyle = player.getColor();
      canvas.beginPath();
      canvas.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
      canvas.fill();
    }

    // ç©å®¶è¾¹æ¡†
    canvas.strokeStyle = '#FFD700';
    canvas.lineWidth = 2;
    canvas.beginPath();
    canvas.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
    canvas.stroke();

    // ç©å®¶åç§°
    canvas.fillStyle = '#FFFFFF';
    canvas.font = 'bold 24px sans-serif';
    canvas.textAlign = 'center';
    canvas.textBaseline = 'middle';
    canvas.fillText(player.getName(), screenPos.x, screenPos.y - radius - 15);
  }

  private drawCreatures(canvas: CanvasRenderingContext2D, creatures: Creature[], camera: Camera, player: Player): void {
    const playerRadius = player.getRadius();
    const imageManager = ImageManager.getInstance();

    for (const creature of creatures) {
      const screenPos: Point = camera.worldToScreen(creature.x, creature.y);
      const radius = creature.getRadius();

      // åªç»˜åˆ¶åœ¨å±å¹•å†…çš„ç”Ÿç‰©
      if (screenPos.x + radius < 0 || screenPos.x - radius > this.canvasWidth ||
          screenPos.y + radius < 0 || screenPos.y - radius > this.canvasHeight) {
        continue;
      }

      // æ ¹æ®ç›¸å¯¹å¤§å°å†³å®šè¾¹æ¡†é¢œè‰²
      let borderColor: string;
      if (creature.evolutionLevel <= player.evolutionLevel) {
        borderColor = '#90EE90'; // å¯ä»¥åƒ - ç»¿è‰²
      } else {
        borderColor = '#FF6B6B'; // å±é™© - çº¢è‰²
      }

      const imageKey = imageManager.getCreatureImageKey(creature.evolutionLevel);
      const cachedImage = imageManager.getCachedImage(imageKey);

      if (cachedImage) {
        // ä½¿ç”¨å›¾ç‰‡ç»˜åˆ¶
        canvas.drawImage(
          cachedImage,
          screenPos.x - radius,
          screenPos.y - radius,
          radius * 2,
          radius * 2
        );
      } else {
        // å›é€€åˆ°åœ†å½¢ç»˜åˆ¶
        canvas.fillStyle = creature.getColor();
        canvas.beginPath();
        canvas.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
        canvas.fill();
      }

      // è¾¹æ¡†
      canvas.strokeStyle = borderColor;
      canvas.lineWidth = 2;
      canvas.beginPath();
      canvas.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
      canvas.stroke();
    }
  }

  private drawBoundaryWarning(canvas: CanvasRenderingContext2D, player: Player, camera: Camera): void {
    const warningDistance = 100;
    const playerRadius = player.getRadius();

    // æ£€æŸ¥æ˜¯å¦é è¿‘è¾¹ç•Œ
    const nearLeft = player.x < warningDistance;
    const nearRight = player.x > GameConstants.WORLD_WIDTH - warningDistance;
    const nearTop = player.y < warningDistance;
    const nearBottom = player.y > GameConstants.WORLD_HEIGHT - warningDistance;

    if (nearLeft || nearRight || nearTop || nearBottom) {
      // çº¢è‰²è­¦å‘Šè¾¹ç¼˜
      canvas.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      canvas.lineWidth = 10;
      canvas.strokeRect(5, 5, this.canvasWidth - 10, this.canvasHeight - 10);

      // è­¦å‘Šæ–‡å­—
      canvas.fillStyle = '#FF6B6B';
      canvas.font = 'bold 28px sans-serif';
      canvas.textAlign = 'center';
      canvas.fillText('âš  æ³¨æ„è¾¹ç•Œ', this.canvasWidth / 2, 30);
    }
  }

  private drawMinimap(canvas: CanvasRenderingContext2D, player: Player, creatures: Creature[], camera: Camera): void {
    const minimapSize = 80;
    const minimapX = this.canvasWidth - minimapSize - 10;
    const minimapY = 10;
    const scaleX = minimapSize / GameConstants.WORLD_WIDTH;
    const scaleY = minimapSize / GameConstants.WORLD_HEIGHT;

    // å°åœ°å›¾èƒŒæ™¯
    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';
    canvas.fillRect(minimapX, minimapY, minimapSize, minimapSize);
    canvas.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    canvas.lineWidth = 1;
    canvas.strokeRect(minimapX, minimapY, minimapSize, minimapSize);

    // ç»˜åˆ¶è§†é‡èŒƒå›´
    const viewX = minimapX + camera.x * scaleX;
    const viewY = minimapY + camera.y * scaleY;
    const viewW = this.canvasWidth * scaleX;
    const viewH = this.canvasHeight * scaleY;
    canvas.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    canvas.strokeRect(viewX, viewY, viewW, viewH);

    // ç»˜åˆ¶æ•Œäººç‚¹
    for (const creature of creatures) {
      const dotX = minimapX + creature.x * scaleX;
      const dotY = minimapY + creature.y * scaleY;

      if (creature.evolutionLevel <= player.evolutionLevel) {
        canvas.fillStyle = '#90EE90'; // å¯é£Ÿç”¨ - ç»¿è‰²
      } else {
        canvas.fillStyle = '#FF6B6B'; // å±é™© - çº¢è‰²
      }
      canvas.beginPath();
      canvas.arc(dotX, dotY, 2, 0, Math.PI * 2);
      canvas.fill();
    }

    // ç»˜åˆ¶ç©å®¶ä½ç½®
    const playerDotX = minimapX + player.x * scaleX;
    const playerDotY = minimapY + player.y * scaleY;
    canvas.fillStyle = '#FFD700';
    canvas.beginPath();
    canvas.arc(playerDotX, playerDotY, 4, 0, Math.PI * 2);
    canvas.fill();
  }

  private drawHUD(canvas: CanvasRenderingContext2D, player: Player, score: number, playTime: number): void {
    // å·¦ä¸Šè§’ä¿¡æ¯
    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';
    canvas.fillRect(5, 5, 180, 90);

    canvas.fillStyle = '#FFFFFF';
    canvas.font = 'bold 28px sans-serif';
    canvas.textAlign = 'left';
    canvas.textBaseline = 'top';
    canvas.fillText(`åˆ†æ•°: ${score}`, 10, 10);

    // æ¸¸æˆæ—¶é—´
    const minutes = Math.floor(playTime / 60);
    const seconds = Math.floor(playTime % 60);
    canvas.font = '24px sans-serif';
    canvas.fillText(`æ—¶é—´: ${minutes}:${seconds.toString().padStart(2, '0')}`, 10, 42);

    // å½“å‰è¿›åŒ–ç­‰çº§
    canvas.fillStyle = player.getColor();
    canvas.fillText(`${player.getName()}`, 10, 70);
  }

  private drawStartPrompt(canvas: CanvasRenderingContext2D): void {
    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';
    canvas.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    canvas.fillStyle = '#FFFFFF';
    canvas.font = 'bold 48px sans-serif';
    canvas.textAlign = 'center';
    canvas.textBaseline = 'middle';
    canvas.fillText('ç‚¹å‡»å¼€å§‹æ¸¸æˆ', this.canvasWidth / 2, this.canvasHeight / 2);
  }

  private drawGameOver(canvas: CanvasRenderingContext2D, score: number, hasWon: boolean): void {
    canvas.fillStyle = 'rgba(0, 0, 0, 0.7)';
    canvas.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    canvas.textAlign = 'center';
    canvas.textBaseline = 'middle';

    if (hasWon) {
      // èƒœåˆ©
      canvas.fillStyle = '#FFD700';
      canvas.font = 'bold 48px sans-serif';
      canvas.fillText('ğŸ‰ æ­å–œä½ å¬å”¤å‡ºç¥é¾™! ğŸ‰', this.canvasWidth / 2, this.canvasHeight / 2 - 60);
    } else {
      // å¤±è´¥
      canvas.fillStyle = '#FF6B6B';
      canvas.font = 'bold 48px sans-serif';
      canvas.fillText('æ¸¸æˆç»“æŸ', this.canvasWidth / 2, this.canvasHeight / 2 - 60);
    }

    canvas.fillStyle = '#FFFFFF';
    canvas.font = '36px sans-serif';
    canvas.fillText(`æœ€ç»ˆåˆ†æ•°: ${score}`, this.canvasWidth / 2, this.canvasHeight / 2 + 20);

    canvas.fillStyle = '#AAAAAA';
    canvas.font = '28px sans-serif';
    canvas.fillText('ç‚¹å‡»è¿”å›ä¸»èœå•', this.canvasWidth / 2, this.canvasHeight / 2 + 80);
  }
}
