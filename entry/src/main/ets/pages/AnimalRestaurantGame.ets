import { GameViewModel } from '../games/animalrestaurant/viewmodel/GameViewModel';
import { GameRenderer } from '../games/animalrestaurant/view/GameRenderer';
import { GameState } from '../games/animalrestaurant/model/GameConstants';
import { Table } from '../games/animalrestaurant/model/Table';
import { Dish } from '../games/animalrestaurant/model/Dish';
import { Customer } from '../games/animalrestaurant/model/Customer';
import { MathUtils, Point } from '../games/animalrestaurant/model/MathUtils';
import { GameConstants } from '../games/animalrestaurant/model/GameConstants';
import { router } from '@kit.ArkUI';

@Entry
@Component
struct AnimalRestaurantGame {
  @State isPlaying: boolean = false;
  @State viewModel: GameViewModel = new GameViewModel();

  private renderer: GameRenderer = new GameRenderer();
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private canvasContext: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  private renderInterval: number | null = null;

  aboutToDisappear(): void {
    this.cleanup();
  }

  build() {
    Column() {
      if (!this.isPlaying) {
        this.HomeView();
      } else {
        this.GameView();
      }
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  HomeView() {
    Column() {
      // è¿”å›æŒ‰é’®
      Row() {
        Button() {
          Text('â† è¿”å›')
            .fontSize(16)
            .fontColor('#FFFFFF')
        }
        .backgroundColor('rgba(255,255,255,0.1)')
        .borderRadius(20)
        .height(36)
        .padding({ left: 15, right: 15 })
        .onClick(() => { router.back(); })
      }
      .width('100%')
      .padding({ left: 20, top: 50 })

      Text('ğŸ¾ åŠ¨ç‰©é¤å… ğŸ¾')
        .fontSize(36)
        .fontWeight(FontWeight.Bold)
        .fontColor('#8B4513')
        .margin({ top: 30, bottom: 10 })

      Text('Animal Restaurant')
        .fontSize(16)
        .fontColor('#A0522D')
        .margin({ bottom: 30 })

      // å¯çˆ±çš„åŠ¨ç‰©å›¾æ ‡
      Row() {
        Text('ğŸ±').fontSize(40)
        Text('ğŸ•').fontSize(40)
        Text('ğŸ°').fontSize(40)
        Text('ğŸ»').fontSize(40)
        Text('ğŸ¦Š').fontSize(40)
        Text('ğŸ¼').fontSize(40)
      }
      .margin({ bottom: 30 })

      // æ¸¸æˆç®€ä»‹
      Column() {
        Text('æ¬¢è¿æ¥åˆ°æ¸©é¦¨çš„åŠ¨ç‰©é¤å…ï¼')
          .fontSize(18)
          .fontColor('#5D4037')
          .margin({ bottom: 10 })

        Text('æ‹›å¾…å¯çˆ±çš„åŠ¨ç‰©é¡¾å®¢')
          .fontSize(14)
          .fontColor('#795548')
        Text('çƒ¹é¥ªç¾å‘³çš„èœè‚´')
          .fontSize(14)
          .fontColor('#795548')
        Text('èµšå–é‡‘å¸å‡çº§é¤å…')
          .fontSize(14)
          .fontColor('#795548')
      }
      .margin({ bottom: 40 })

      // å¼€å§‹æŒ‰é’®
      Button('å¼€å§‹è¥ä¸š')
        .fontSize(24)
        .fontColor('#FFFFFF')
        .backgroundColor('#FF9800')
        .borderRadius(30)
        .width(200)
        .height(50)
        .shadow({ radius: 10, color: '#FF9800', offsetX: 0, offsetY: 5 })
        .onClick(() => { this.startGame(); })

      // æç¤º
      Text('ç‚¹å‡»ç”»é¢ä¸æ¸¸æˆäº’åŠ¨')
        .fontSize(12)
        .fontColor('#9E9E9E')
        .margin({ top: 30 })
    }
    .width('100%')
    .height('100%')
    .linearGradient({
      angle: 180,
      colors: [['#FFF8E7', 0.0], ['#FFE4C4', 0.5], ['#FFDAB9', 1.0]]
    })
  }

  @Builder
  GameView() {
    Column() {
      Canvas(this.canvasContext)
        .width(GameConstants.CANVAS_WIDTH)
        .height(GameConstants.CANVAS_HEIGHT)
        .backgroundColor(GameConstants.COLOR_BACKGROUND)
        .onReady(() => { this.onCanvasReady(); })
        .onClick((event) => { this.onCanvasClick(event.x, event.y); })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .backgroundColor('#F5F5DC')
  }

  private startGame(): void {
    this.isPlaying = true;
    this.viewModel = new GameViewModel();
  }

  private onCanvasReady(): void {
    if (this.renderInterval !== null) {
      clearInterval(this.renderInterval);
    }

    // ç«‹å³å¼€å§‹æ¸¸æˆ
    this.viewModel.startGame();

    // å¯åŠ¨æ¸²æŸ“å¾ªç¯
    this.renderInterval = setInterval(() => { this.render(); }, 1000 / 60);
  }

  private onCanvasClick(x: number, y: number): void {
    const state = this.viewModel.gameState;

    if (state === GameState.IDLE) {
      this.viewModel.startGame();
      return;
    }

    if (state === GameState.PAUSED) {
      this.viewModel.resumeGame();
      return;
    }

    if (state === GameState.PLAYING) {
      // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯èœå“ã€é¤æ¡Œè¿˜æ˜¯é¡¾å®¢
      const clickPoint: Point = { x, y };

      // ä¼˜å…ˆæ£€æŸ¥èœå“ï¼ˆå‡†å¤‡å¥½çš„èœå“éœ€è¦ç‚¹å‡»ä¸Šèœï¼‰
      const dishes = this.viewModel.getDishes();
      for (const dish of dishes) {
        if (dish.isReady()) {
          const rect = dish.getCollisionRect();
          if (MathUtils.isPointInRect(clickPoint, rect)) {
            this.viewModel.clickDish(dish.id);
            return;
          }
        }
      }

      // æ£€æŸ¥é¤æ¡Œï¼ˆéœ€è¦æ¸…ç†çš„é¤æ¡Œï¼‰
      const tables = this.viewModel.getTables();
      for (const table of tables) {
        const rect = table.getCollisionRect();
        if (MathUtils.isPointInRect(clickPoint, rect)) {
          this.viewModel.clickTable(table.id);
          return;
        }
      }

      // æ£€æŸ¥é¡¾å®¢ï¼ˆå¯ä»¥å®‰æŠšç­‰å¾…çš„é¡¾å®¢ï¼‰
      const customers = this.viewModel.getAllCustomers();
      for (const customer of customers) {
        const rect = customer.getCollisionRect();
        if (MathUtils.isPointInRect(clickPoint, rect)) {
          this.viewModel.clickCustomer(customer.id);
          return;
        }
      }
    }
  }

  private render(): void {
    const engine = this.viewModel.getEngine();
    this.renderer.render(
      this.canvasContext,
      this.viewModel.getTables(),
      this.viewModel.getWaitingCustomers(),
      this.viewModel.getAllCustomers(),
      this.viewModel.getDishes(),
      this.viewModel.getRestaurant(),
      this.viewModel.gameState
    );
  }

  private cleanup(): void {
    if (this.renderInterval !== null) {
      clearInterval(this.renderInterval);
      this.renderInterval = null;
    }
    this.viewModel.destroy();
  }
}
